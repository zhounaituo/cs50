# CS50 笔记

- week 0
	- 主要介绍了课程内容：Scratch、C、Javascript、算法、人工智能...(没记住)
	- 重要的观点：
		- 对于写程序，一次只处理好一件事，并慢慢迭代版本进行完善。
		- 编程是解决问题的艺术。
		- 课程的内容非常多，可能无法完全吸收完。重要的是关注自己的成长（课程之后自己的位置和之前的比较）
	- 数字如何表示一切
		- 数字：10 -> 2 （二进制）
		- 单词： A -> 56 
		- 颜色： 1e1e1e -> 黑色 （十六进制）
		- 图片： 1e1e1e -> 颜色块 -> 图片
		- 表情：Unicode -> 表情 （十六进制）
		- 视频： 图片 -> 视频
		- 音乐
	- 有关 Scratch 
		- 伪代码：用人类语言描述程序解决问题的方法。
		- 语言的组成：
			- 条件
			- 循环
			- 函数
			- ...
		- 使代码更加简洁的方法
			- 抽象
			- 模块
	- 算法的考量：效率（时间/数据量）、准确率。
	- 其他
		- 字节 = 8 位 （2^3）
- week1
	- 讲座
		- 这一周主要讲了 C 语言。
		- 重要的观点
			- 不要重复自己。这样有助于之后的维护和修改。
			- 计数从 0 开始，不浪费比特。
			- 语言并不需要了解所有函数，只要了解在哪里（库/手册）得到解决就好。语言在发展时会包含许多内容，使得语言越来越大。
		- C 语言特性和优化
			- `int main(void)` 是有隐藏返回值的，0 表示正常，其他的是一些错误代码。
			- 最好将 `main()` 方法放在程序的最前。方便其他人寻找和修改代码。
		- 一些程序错误
			- 内存溢出。
				- 计算机只能表现有限的数字，当数字超出表示范围时，就会出现 “内存溢出“ 错误。
			- 小数精确度
				- 同样是，计算机无法储存精确数据，导致在数字的四则运算时，可能出现小数并不精准的问题。
				- 比如，可以测试一下 1/3
			- 运算截断错误
				- 不同类型换算时，可能出现小数被截断的问题。比如 int 类型的 1/3 = 0
		- 简单的介绍了一下 Linux 系统
			- cd
			- mv
			- rm
			- cp
			- ls
			- mkdir
			- mrdir
		- 程序的运行过程
			- 编写源码（code）
			- 编译机器码（make）
			- 运行
	- 阅读 [Style Guide for C — CS50 Docs](https://cs50.readthedocs.io/style/c/)
		- 每行不要超过 100 字符（以前的屏幕建议是 80）。
		- 备注
			- 备注的作用
				- 给以后的自己维护时
				- 给别人查看时
			- 好的备注
				- 主要解决两个问题
					- 这个功能是什么
					- 为什么这样实现
				- 太长和太短的备注都不好。
				- 最好每个几行备注一下。
				- 每个文件的上面总结一下。
				- 每个方法上总结一下。
				- 除特殊名称，首字母大写。
		- 之后是对于不同方法的书写建议，大体建议如下
			- 花括号单独占一行
			- 空格
				- 方法体要缩进（4个空格）
				- 方法名后的括号`()`有空格
				- 其他`()`周围没有空格。 
				- 运算符周围有空格。
			- 其他
				- switch 的每个分支都要有 `break;`
				- for 循环建议使用 `i-k` 作为参数，超过 `k` 的重新考虑程序设计。
				- 多个单词的参数名以`_`连接。
	- 其他视频
		- 主要作用是详细描述了课程中没有详细讲到的语言部分。
		- 变量
			- int 
			- long
			- float
			- double
			- char 
			- string
			- bool
		- 操作符
			- + - * /
			- and &&
			- or ||
			- not !
		- 条件语句
			- if
			- if else
			- switch
			- ?: 三目运算符
		- 循环
			- while 
			- do while 总是执行一次
			- for 适合有明确次数的循环
		- 命令行
			- ls
			- cd
			- cp
			- mv
			- rm
				- -f 强制执行
				- -r 内部文件递归
			- mkdir
			- rmdir
			- sudo
			- touch
			- telnet
- week2
	- 这周主要谈论了一部分的编译原理、提了一嘴逆向工程、详细讲解了 Array、String 以及了解了一下密码学。
	- 编译原理：从源码到可执行文件一共经历了 4 部分
		- 预处理(pro-processing)：将使用到的包引用转变为原型。`#include <stdio.h>` -> `void printf(string value)`
		- 编译（compiling)：将预处理后的代码编译为汇编语言。`2 + 3` -> `add 2 3`
		- 汇编（assembling）：将编译代码转变为二进制文件，这是生成了文件。
		- 连接（linking)：将库的二进制文件和上述文件连接。
	- 逆向工程：就是从二进制文件倒推生成源文件。但是，在生成源文件时，会有大量的信息丢失（变量名...），所以本质上逆向工程是十分困难的。
	- Array
		- Array 的数据是有序的储存在内存中。
		- Array 储存的是单类型的数据。
		- Array 没有获取长度的方式，需要自己管理长度。
		- 声明的方式：`int Array[3]; or int Array[] = {72, 73, 33}`
		- Array 不能够直接通过 `=` 复制，需要通过循环来复制。
		- Array 作为参数时，是以`值传递`，意味着，如果传递途中改变，那么原值也会改变。
		- Array 有超出索引而引发错误的可能。
	- String
		- String 是一个字符数组，而字符是一堆数字，可以通过数字计算来转换大小写（Unicode），不过最好使用 `<string.h>` 提供的 `toupper`。
		- 每个字符串都有一个结尾的哨兵字符（`\0`) ，用来标记结束位置。所以每个字符串的长度会比原有数组大 1。
		- 迭代 String 的方式
			- 以哨兵字符为条件的循环。（不推荐）
			- 以 `strlen` 为条件的循环。`for (int i = 0, n = strlen(name), i < n, i++)`
	- 命令行参数
		- `int main(int argc, int argv[])`
		- main 方法默认返回 0 作为程序正常的标志。通过手动返回不同的数字代码可以用来标记错误。测试工具的原理就是如此。
	- 密码学
		- 加密
		- 解密
		- 密钥
	- Debugger 
		- printf 不推荐，每次修改都需要重新编译非常浪费时间。
		- debugger 推荐使用
		- 橡胶鸭调试。向非生命体描述程序的构成，可以发现自己的错误。
	- 其他
		- make 在执行 clang 所执行的内容，只是简化了步骤。
		- 全局变量：`const int N`，放在所有方法外，const 保证不可变，通常建议大写。
		- 命令行的艺术，`cowsay` 自己玩玩
- week3
	- 这周主要讲解了算法。
	- 主要的思想
		- 糟糕的代码有股代码气味。
		- 递归是一种以资源换资源的平衡。
		- 当参数足够大时，可以忽略其他系数所带来的影响。
	- 算法![[Pasted image 20240727105408.png]]
		- 搜索
			- 线性算法
			- 二分法
		- 排序
			- 选择
			- 冒泡
			- 合并（递归）
	- 算法的效率
		- 效率的几种类型（n表示数据的个数）
			- $n^2$：选择排序
			- $n\log n$：合并排序
			- $n$：二分法
			- $\log n$：
			- $1$
		- 算法的符号
			- $O$：表示算法大运算量时的情况。
			- $\Omega$：表示算法最小运算量的情况。
			- $\Theta$：表示算法最大和最小的情况相同时。
		- 效率的考量：数据在内存中移动的次数。
	- 数据构建 `typedef struct`
		- ![[Pasted image 20240727105529.png]]
	- 其他
		- 伪代码有利于思考问题，建议多用。
		- `time` 可以获取代码的运行时间。